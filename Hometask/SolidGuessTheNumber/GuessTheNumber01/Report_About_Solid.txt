Отчет по применению принципов SOLID в игре "Угадай число"
Введение
Данный отчет описывает применение пяти принципов SOLID в реализации игры "Угадай число". Каждый принцип продемонстрирован на конкретных примерах из кода проекта.

1. Принцип единственной ответственности (SRP - Single Responsibility Principle)
Определение: Каждый класс должен иметь только одну причину для изменения, то есть выполнять только одну ответственность.

Применение в коде:

1.1 Разделение ответственностей по интерфейсам:
IGameSettings - отвечает исключительно за хранение настроек игры (диапазон чисел, количество попыток)

INumberGenerator - отвечает только за генерацию случайных чисел

IInputProvider - отвечает только за получение ввода от пользователя

IOutputProvider - отвечает только за вывод информации пользователю

IGameLogger - отвечает только за логирование событий игры

1.2 Разделение ответственностей в классах:
RandomNumberGenerator - имеет единственную задачу: генерировать случайные числа

ConsoleInput - занимается только чтением ввода с консоли

ConsoleOutput - занимается только выводом в консоль

ConsoleLogger и FileLogger - занимаются только записью логов

GameSettings - хранят только настройки, не содержат бизнес-логики

1.3 Основной класс игры:
GuessNumberGame - имеет четко определенную ответственность: управление процессом игры. Он не занимается:

Генерацией чисел (делегировано INumberGenerator)

Вводом/выводом (делегировано IInputProvider/IOutputProvider)

Логированием (делегировано IGameLogger)

Хранением настроек (делегировано IGameSettings)

Преимущества: Упрощается тестирование, поддержка и модификация кода. Изменение формата вывода не затрагивает логику игры.

2. Принцип открытости/закрытости (OCP - Open/Closed Principle)
Определение: Программные сущности должны быть открыты для расширения, но закрыты для модификации.

Применение в коде:

2.1 Иерархия настроек игры:
csharp
public abstract class GameSettingsBase : IGameSettings
{
    public abstract int MinNumber { get; }
    public abstract int MaxNumber { get; }
    public abstract int MaxAttempts { get; }
}

public class DefaultGameSettings : GameSettingsBase { /* ... */ }
public class HardGameSettings : GameSettingsBase { /* ... */ }
public class CustomGameSettings : GameSettingsBase { /* ... */ }
Результат: Для добавления нового типа настроек (например, настроек из файла конфигурации ConfigFileGameSettings) достаточно:

Унаследоваться от GameSettingsBase

Реализовать абстрактные свойства

Не требуется изменять существующий код GameSettingsBase или GuessNumberGame

2.2 Иерархия логгеров:
csharp
public abstract class LoggerBase : IGameLogger
{
    public abstract void Log(string message);
    public virtual void LogGameStart(int targetNumber) { /* ... */ }
    // ...
}

public class ConsoleLogger : LoggerBase { /* ... */ }
public class FileLogger : LoggerBase { /* ... */ }
Результат: Для добавления нового типа логгера (например, DatabaseLogger или NetworkLogger):

Унаследоваться от LoggerBase

Реализовать метод Log()

При необходимости переопределить виртуальные методы

Не требуется изменять существующий код

2.3 Генераторы чисел:
Интерфейс INumberGenerator позволяет добавлять новые реализации без изменения кода игры:

RandomNumberGenerator - использует стандартный генератор случайных чисел

Можно добавить SecureNumberGenerator (криптографически безопасный) без изменения GuessNumberGame

Преимущества: Система легко расширяема без риска сломать существующий функционал.

3. Принцип подстановки Лисков (LSP - Liskov Substitution Principle)
Определение: Объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы.

Применение в коде:

3.1 Настройки игры:
Все классы-наследники GameSettingsBase могут использоваться везде, где ожидается IGameSettings:

csharp
// В Program.cs - все работает корректно
IGameSettings settings;
switch (choice)
{
    case "1":
        settings = new DefaultGameSettings();  // Подстановка 1
        break;
    case "2":
        settings = new HardGameSettings();     // Подстановка 2
        break;
    case "3":
        settings = new CustomGameSettings(...);// Подстановка 3
        break;
}

// GuessNumberGame корректно работает с любым типом настроек
var game = new GuessNumberGame(settings, ...);
3.2 Логгеры:
ConsoleLogger и FileLogger полностью совместимы с LoggerBase:

csharp
// Можно использовать любой логгер
IGameLogger logger = new ConsoleLogger();  // Работает
// ИЛИ
IGameLogger logger = new FileLogger("log.txt");  // Работает без изменений

// GuessNumberGame работает с любым логгером
var game = new GuessNumberGame(..., logger);
3.3 Ввод/вывод:
Если бы у нас были альтернативные реализации (например, GraphicalInput для GUI), они могли бы заменять ConsoleInput без проблем.

Ключевой аспект: Все производные классы:

Не нарушают контракты базовых классов

Имеют согласованное поведение

Не выбрасывают непредвиденных исключений

Сохраняют инварианты базовых классов

Преимущества: Повышение надежности и предсказуемости системы.

4. Принцип разделения интерфейсов (ISP - Interface Segregation Principle)
Определение: Клиенты не должны зависеть от методов, которые они не используют. Много специализированных интерфейсов лучше, чем один универсальный.

Применение в коде:

4.1 Разделение интерфейсов ввода/вывода:
Вместо одного монолитного интерфейса:

csharp
// ПЛОХО: один большой интерфейс
public interface IGameInputOutput
{
    int GetNumberInput();
    string GetStringInput();
    void DisplayMessage(string message);
    void DisplayHint(string hint);
    void DisplayError(string error);
    // ... много других методов
}
Мы используем специализированные интерфейсы:

csharp
// ХОРОШО: разделенные интерфейсы
public interface IInputProvider
{
    int GetNumberInput();
    string GetStringInput();
}

public interface IOutputProvider
{
    void DisplayMessage(string message);
    void DisplayHint(string hint);
}
4.2 Преимущества разделения:
GuessNumberGame зависит только от нужных ему методов:

Использует IInputProvider.GetNumberInput() для получения чисел

Использует IOutputProvider.DisplayMessage() и DisplayHint() для вывода

Не зависит от методов, которые не использует

Гибкость реализации:

Можно создать SilentOutput (ничего не выводит) для тестирования

Можно создать TestInput (возвращает предопределенные значения) для тестов

Каждый класс реализует только необходимые ему интерфейсы

Упрощение тестирования:

csharp
// Mock для тестирования
public class MockInput : IInputProvider
{
    private readonly Queue<int> _numbers;
    
    public MockInput(params int[] numbers)
    {
        _numbers = new Queue<int>(numbers);
    }
    
    public int GetNumberInput() => _numbers.Dequeue();
    public string GetStringInput() => "test";
}
4.3 Другие интерфейсы также разделены:
IGameLogger - только логирование

INumberGenerator - только генерация чисел

IGameSettings - только предоставление настроек

Преимущества: Уменьшение связности, упрощение тестирования, повышение гибкости системы.

5. Принцип инверсии зависимостей (DIP - Dependency Inversion Principle)
Определение: Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Применение в коде:

5.1 Конструктор GuessNumberGame:
csharp
public GuessNumberGame(
    IGameSettings settings,        // Зависимость от абстракции
    INumberGenerator generator,    // Зависимость от абстракции
    IInputProvider input,          // Зависимость от абстракции
    IOutputProvider output,        // Зависимость от абстракции
    IGameLogger logger)            // Зависимость от абстракции
{
    // Внедрение зависимостей через конструктор
}
Ключевые аспекты:

GuessNumberGame (модуль верхнего уровня) зависит только от интерфейсов

Конкретные реализации (модули нижнего уровня) также зависят от тех же интерфейсов

Связь через абстракции, а не через конкретные классы

5.2 Инверсия управления в Program.cs:
csharp
// Создание зависимостей
IGameSettings settings = new DefaultGameSettings();
INumberGenerator generator = new RandomNumberGenerator();
IInputProvider input = new ConsoleInput();
IOutputProvider output = new ConsoleOutput();
IGameLogger logger = new ConsoleLogger();

// Внедрение зависимостей
var game = new GuessNumberGame(settings, generator, input, output, logger);
5.3 Возможности, предоставляемые DIP:
Легкая замена реализаций:

csharp
// Замена логгера
IGameLogger logger = new FileLogger("game.log");
// ИЛИ
IGameLogger logger = new CompositeLogger(
    new ConsoleLogger(),
    new FileLogger("game.log")
);
Упрощение тестирования:

csharp
// Тестовые двойники
var mockSettings = new Mock<IGameSettings>();
mockSettings.Setup(m => m.MaxAttempts).Returns(3);

var stubGenerator = new Mock<INumberGenerator>();
stubGenerator.Setup(g => g.GenerateNumber(1, 100)).Returns(42);
Конфигурируемость:

csharp
// Разные конфигурации для разных сред
IGameLogger CreateLoggerForEnvironment(string env)
{
    return env switch
    {
        "Development" => new ConsoleLogger(),
        "Production" => new FileLogger("/var/log/game.log"),
        _ => new NullLogger()
    };
}
5.4 Сравнение с нарушением DIP:
csharp
// НАРУШЕНИЕ DIP: зависимости от конкретных классов
public class GuessNumberGame
{
    private readonly DefaultGameSettings _settings;
    private readonly RandomNumberGenerator _generator;
    private readonly ConsoleInput _input;
    private readonly ConsoleOutput _output;
    
    // Жесткая связь с конкретными реализациями
}
Преимущества нашего подхода:

Снижение связанности компонентов

Упрощение модульного тестирования

Гибкость в выборе реализаций

Упрощение рефакторинга и модификации

6. Дополнительные аспекты архитектуры
6.1 Слоистая архитектура:
Core - базовые интерфейсы и модели

Core/Services - реализации сервисов

Game - бизнес-логика игры

Program - точка входа и конфигурация

6.2 Code Style и качество кода:
Единые соглашения об именовании

Четкое разделение namespace

Отсутствие "магических чисел"

Осмысленные имена переменных и методов

Обработка ошибок ввода

6.3 Тестируемость:
Архитектура позволяет легко создавать модульные тесты:

csharp
[Test]
public void Game_Should_Win_When_CorrectGuess()
{
    // Arrange
    var settings = new DefaultGameSettings();
    var generator = new MockNumberGenerator(42);
    var input = new MockInput(42);
    var output = new MockOutput();
    var logger = new MockLogger();
    
    var game = new GuessNumberGame(settings, generator, input, output, logger);
    
    // Act
    var result = game.Play();
    
    // Assert
    Assert.IsTrue(result.IsWin);
    Assert.AreEqual(1, result.AttemptsUsed);
}
7. Заключение
В проекте "Угадай число" успешно применены все пять принципов SOLID:

SRP - каждый класс имеет четко определенную единственную ответственность

OCP - система легко расширяется без модификации существующего кода

LSP - производные классы полностью заменяемы без нарушения работы системы

ISP - специализированные интерфейсы предотвращают зависимости от неиспользуемых методов

DIP - зависимости направлены на абстракции, что обеспечивает гибкость и тестируемость

Архитектура проекта демонстрирует, как применение SOLID принципов приводит к созданию:

Гибкой и расширяемой системы

Легко тестируемого кода

Поддерживаемой и понятной структуры

Минимально связанных компонентов